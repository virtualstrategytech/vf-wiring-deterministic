[{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\convocore\\CalButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\convocore\\CalButton_Dark.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\convocore\\embed.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\convocore\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\novain-platform\\components\\server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\novain-platform\\prompts\\server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\novain-platform\\webhook\\mock_business_server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\novain-platform\\webhook\\server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\prompts_backup_20251012141417\\prompts_server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\prompts_fix_backup_20251012142635\\prompts_server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\scripts\\convert-copilot-chat.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\scripts\\pretest.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\check_header.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\debug_llm_logging.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\globalSetup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\globalTeardown.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":28,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const fs = require('fs');\r\nconst path = require('path');\r\nconst { spawnSync } = require('child_process');\r\n\r\nmodule.exports = async () => {\r\n  const pidFile = path.resolve(__dirname, 'webhook.pid');\r\n  const logFile = path.resolve(__dirname, 'globalSetup.log');\r\n\r\n  function appendLog(line) {\r\n    try {\r\n      fs.appendFileSync(logFile, `[${new Date().toISOString()}] ${line}\\n`);\r\n    } catch {}\r\n  }\r\n\r\n  appendLog('globalTeardown: starting');\r\n\r\n  // Best-effort: ask any test server helper to close sockets before killing\r\n  try {\r\n    const serverHelper = require('./helpers/server-helper');\r\n    if (serverHelper && typeof serverHelper._forceCloseAllSockets === 'function') {\r\n      try {\r\n        serverHelper._forceCloseAllSockets();\r\n        appendLog('globalTeardown: invoked serverHelper._forceCloseAllSockets');\r\n      } catch (e) {\r\n        appendLog(`globalTeardown: serverHelper._forceCloseAllSockets error: ${e && e.message}`);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    // ignore; helper may not be present in all runs\r\n  }\r\n\r\n  // Try to kill the spawned webhook process (if any)\r\n  try {\r\n    if (!fs.existsSync(pidFile)) {\r\n      appendLog('globalTeardown: pid file not found; nothing to kill');\r\n      return;\r\n    }\r\n\r\n    let pid;\r\n    try {\r\n      pid = Number(fs.readFileSync(pidFile, 'utf8').trim());\r\n    } catch (e) {\r\n      appendLog(`globalTeardown: failed reading pid file: ${e.message}`);\r\n    }\r\n\r\n    if (!pid || Number.isNaN(pid)) {\r\n      appendLog('globalTeardown: invalid pid; removing pid file if present');\r\n      try {\r\n        fs.unlinkSync(pidFile);\r\n        appendLog('globalTeardown: pid file removed');\r\n      } catch {}\r\n      return;\r\n    }\r\n\r\n    appendLog(`globalTeardown: attempting graceful kill for pid ${pid}`);\r\n\r\n    // Try a graceful kill first\r\n    try {\r\n      process.kill(pid, 'SIGTERM');\r\n      appendLog(`globalTeardown: sent SIGTERM to ${pid}`);\r\n    } catch (e) {\r\n      appendLog(`globalTeardown: process.kill(SIGTERM) failed: ${e.message}`);\r\n    }\r\n\r\n    // Wait up to N ms for process to exit\r\n    const waitMs = 5000;\r\n    const start = Date.now();\r\n    let alive = true;\r\n    while (Date.now() - start < waitMs) {\r\n      try {\r\n        process.kill(pid, 0); // throws if not running\r\n        // still alive\r\n        await new Promise((r) => setTimeout(r, 200));\r\n      } catch {\r\n        alive = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (alive) {\r\n      appendLog(`globalTeardown: process ${pid} still alive after ${waitMs}ms; forcing kill`);\r\n      try {\r\n        if (process.platform === 'win32') {\r\n          spawnSync('taskkill', ['/PID', String(pid), '/T', '/F']);\r\n          appendLog(`globalTeardown: taskkill invoked for ${pid}`);\r\n        } else {\r\n          try {\r\n            process.kill(pid, 'SIGKILL');\r\n            appendLog(`globalTeardown: sent SIGKILL to ${pid}`);\r\n          } catch (e) {\r\n            appendLog(`globalTeardown: SIGKILL failed: ${e.message}; attempting pkill -P`);\r\n            spawnSync('pkill', ['-TERM', '-P', String(pid)]);\r\n            appendLog('globalTeardown: pkill invoked for child processes');\r\n          }\r\n        }\r\n      } catch (e) {\r\n        appendLog(`globalTeardown: force kill attempt failed: ${e.message}`);\r\n      }\r\n\r\n      // Final short wait\r\n      await new Promise((r) => setTimeout(r, 300));\r\n      try {\r\n        process.kill(pid, 0);\r\n        appendLog(`globalTeardown: process ${pid} still exists after forced kill`);\r\n      } catch {\r\n        appendLog(`globalTeardown: process ${pid} no longer exists`);\r\n      }\r\n    } else {\r\n      appendLog(`globalTeardown: process ${pid} exited gracefully`);\r\n    }\r\n\r\n    // Cleanup pid file\r\n    try {\r\n      if (fs.existsSync(pidFile)) {\r\n        fs.unlinkSync(pidFile);\r\n        appendLog('globalTeardown: pid file removed');\r\n      }\r\n    } catch (e) {\r\n      appendLog(`globalTeardown: failed to remove pid file: ${e.message}`);\r\n    }\r\n  } catch (e) {\r\n    appendLog(`globalTeardown: unexpected error: ${e && e.message}`);\r\n  }\r\n\r\n  // Append final marker\r\n  appendLog('globalTeardown: finished');\r\n  // Best-effort: destroy global http/https agents to avoid Jest open-handle warnings\r\n  try {\r\n    try {\r\n      const http = require('http');\r\n      if (http && http.globalAgent && typeof http.globalAgent.destroy === 'function') {\r\n        http.globalAgent.destroy();\r\n        appendLog('globalTeardown: destroyed http.globalAgent');\r\n      }\r\n    } catch (e) {\r\n      appendLog(`globalTeardown: http agent destroy error: ${e && e.message}`);\r\n    }\r\n\r\n    try {\r\n      const https = require('https');\r\n      if (https && https.globalAgent && typeof https.globalAgent.destroy === 'function') {\r\n        https.globalAgent.destroy();\r\n        appendLog('globalTeardown: destroyed https.globalAgent');\r\n      }\r\n    } catch (e) {\r\n      appendLog(`globalTeardown: https agent destroy error: ${e && e.message}`);\r\n    }\r\n  } catch {}\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\hello.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\helpers\\request-helper.fixed.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\helpers\\request-helper.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":14,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const serverHelper = require('./server-helper');\r\nconst fetch = require('node-fetch');\r\n\r\nasync function requestApp(\r\n  app,\r\n  { method = 'post', path = '/', body, headers = {}, timeout = 5000 } = {}\r\n) {\r\n  // If app is a string base URL, use node-fetch directly.\r\n  if (typeof app === 'string') {\r\n    const url = `${app}${path}`;\r\n    // provide a clearer error when an invalid/empty base is supplied\r\n    try {\r\n      new URL(url);\r\n    } catch (err) {\r\n      throw new Error(`requestApp: invalid URL constructed from base: ${String(app)}`);\r\n    }\r\n    const controller = new AbortController();\r\n    const to = setTimeout(() => controller.abort(), timeout || 5000);\r\n    try {\r\n      const resp = await fetch(url, {\r\n        method: method.toUpperCase(),\r\n        // explicitly close connections to avoid keep-alive sockets lingering in CI\r\n        headers: Object.assign(\r\n          { 'Content-Type': 'application/json', Connection: 'close' },\r\n          headers || {}\r\n        ),\r\n        body: body ? JSON.stringify(body) : undefined,\r\n        signal: controller.signal,\r\n      });\r\n      const text = await resp.text();\r\n      let parsed;\r\n      try {\r\n        parsed = JSON.parse(text);\r\n      } catch {\r\n        parsed = text;\r\n      }\r\n      return { status: resp.status, headers: resp.headers.raw && resp.headers.raw(), body: parsed };\r\n    } finally {\r\n      clearTimeout(to);\r\n    }\r\n  }\r\n\r\n  // If app looks like an Express app (function with listen), start a\r\n  // controlled ephemeral server and perform a normal HTTP request. This\r\n  // avoids letting supertest create internal servers which can leave\r\n  // bound anonymous handles detected by Jest.\r\n  if (app && typeof app.listen === 'function') {\r\n    const started = await serverHelper.startTestServer(app);\r\n    const base = started.base;\r\n    const close = started.close;\r\n    const url = `${base}${path}`;\r\n    const controller = new AbortController();\r\n    const to = setTimeout(() => controller.abort(), timeout || 5000);\r\n    try {\r\n      const resp = await fetch(url, {\r\n        method: method.toUpperCase(),\r\n        // explicitly close connections to avoid keep-alive sockets lingering in CI\r\n        headers: Object.assign(\r\n          { 'Content-Type': 'application/json', Connection: 'close' },\r\n          headers || {}\r\n        ),\r\n        body: body ? JSON.stringify(body) : undefined,\r\n        signal: controller.signal,\r\n      });\r\n      const text = await resp.text();\r\n      let parsed;\r\n      try {\r\n        parsed = JSON.parse(text);\r\n      } catch {\r\n        parsed = text;\r\n      }\r\n      return { status: resp.status, headers: resp.headers.raw && resp.headers.raw(), body: parsed };\r\n    } finally {\r\n      clearTimeout(to);\r\n      try {\r\n        await close();\r\n      } catch {}\r\n      try {\r\n        if (serverHelper && typeof serverHelper._forceCloseAllSockets === 'function') {\r\n          serverHelper._forceCloseAllSockets();\r\n        }\r\n      } catch {}\r\n    }\r\n  }\r\n\r\n  // For other inputs, fallback to throwing to surface incorrect usage.\r\n  throw new Error('requestApp expects an Express app or a base URL string');\r\n}\r\n\r\nmodule.exports = { requestApp };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\helpers\\server-helper.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\helpers\\server-helper.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\in_process.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\jest.setup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\llm_stub.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\regression_raw_mirror.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\tests\\webhook.smoke.test.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":44,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"∩╗┐const http = require('http');\r\nconst https = require('https');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nconst secretFile = path.resolve(__dirname, 'webhook.secret');\r\nconst key =\r\n  process.env.WEBHOOK_API_KEY ||\r\n  (fs.existsSync(secretFile) ? fs.readFileSync(secretFile, 'utf8').trim() : 'test123');\r\n\r\nconst rawBase = (process.env.WEBHOOK_BASE || '').trim();\r\n// Default to local server when no base provided\r\nconst base = rawBase || 'http://127.0.0.1:3000';\r\n\r\n// If the user supplied a remote base but didn't provide an API key, fail fast\r\n// with a clear message so CI logs are actionable (instead of hitting \"Invalid URL\").\r\nif (rawBase) {\r\n  const hasEnvKey = Boolean(process.env.WEBHOOK_API_KEY);\r\n  const secretFileExists = fs.existsSync(secretFile);\r\n  if (!hasEnvKey && !secretFileExists) {\r\n    throw new Error(\r\n      'WEBHOOK_BASE is set but WEBHOOK_API_KEY is not available (env or webhook.secret).\\nUse SKIP_SMOKE=true to skip smoke tests, or set the secret in the repo/runner.'\r\n    );\r\n  }\r\n}\r\n\r\nfunction _maskBaseForLogs(b) {\r\n  try {\r\n    const u = new URL(b);\r\n    return `${u.protocol}//${u.hostname}${u.port ? ':' + u.port : ''}`;\r\n  } catch {\r\n    // fallback: don't print the raw value to logs to avoid leaking secrets\r\n    return '[invalid-base]';\r\n  }\r\n}\r\n\r\n// Strict validation: ensure `base` is a well-formed URL early so CI shows a\r\n// clear, masked diagnostic instead of a low-level TypeError inside helpers.\r\ntry {\r\n  // only validate when a non-empty base was supplied (local default is fine)\r\n  if (rawBase) {\r\n    new URL(base);\r\n  }\r\n} catch (err) {\r\n  throw new Error(`WEBHOOK_BASE is not a valid URL: ${_maskBaseForLogs(base)}`);\r\n}\r\n\r\n// Allow CI to override per-request timeouts when contacting deployed services\r\nconst HEALTH_TIMEOUT = Number(process.env.WEBHOOK_HEALTH_TIMEOUT) || 5000;\r\nconst PING_TIMEOUT = Number(process.env.WEBHOOK_PING_TIMEOUT) || 7000;\r\nconst GENERATE_TIMEOUT = Number(process.env.WEBHOOK_GENERATE_TIMEOUT) || 45000;\r\n\r\ndescribe('webhook smoke', () => {\r\n  if (process.env.SKIP_SMOKE === 'true') {\r\n    // Skip entire smoke suite in CI when no deployed service is available\r\n    // Provide a dummy test so Jest doesn't treat the file as empty (which fails)\r\n    console.warn('SKIP_SMOKE=true, skipping webhook smoke tests');\r\n    test('skipped in CI', () => {\r\n      expect(true).toBe(true);\r\n    });\r\n    return;\r\n  }\r\n  // Allow longer for remote operations in CI (business/prompt services may be slower)\r\n  jest.setTimeout(60000);\r\n\r\n  afterAll(async () => {\r\n    try {\r\n      if (http && http.globalAgent && typeof http.globalAgent.destroy === 'function') {\r\n        http.globalAgent.destroy();\r\n      }\r\n      if (https && https.globalAgent && typeof https.globalAgent.destroy === 'function') {\r\n        https.globalAgent.destroy();\r\n      }\r\n      await new Promise((r) => setImmediate(r));\r\n    } catch {}\r\n  });\r\n\r\n  test('GET /health returns ok', async () => {\r\n    // defensive: ensure base looks like a URL\r\n    if (!base || !(base.startsWith('http://') || base.startsWith('https://'))) {\r\n      throw new Error(`WEBHOOK_BASE is not a valid HTTP URL: ${_maskBaseForLogs(base)}`);\r\n    }\r\n    const url = `${base}/health`;\r\n    const retries = Number(process.env.WEBHOOK_HEALTH_RETRIES) || 12;\r\n    const retryDelay = Number(process.env.WEBHOOK_HEALTH_RETRY_DELAY) || 2000;\r\n\r\n    // Try multiple times to allow the remote service to become healthy\r\n    let lastErr;\r\n    let text;\r\n    for (let attempt = 1; attempt <= retries; attempt++) {\r\n      try {\r\n        text = await getText(url, HEALTH_TIMEOUT);\r\n        lastErr = null;\r\n        break;\r\n      } catch (err) {\r\n        lastErr = err;\r\n        if (attempt < retries) {\r\n          // wait then retry\r\n          await new Promise((r) => setTimeout(r, retryDelay));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lastErr) throw lastErr;\r\n    expect(typeof text).toBe('string');\r\n    expect(text.trim().toLowerCase()).toBe('ok');\r\n  });\r\n\r\n  test('POST /webhook (ping) returns 2xx', async () => {\r\n    const body = { action: 'ping', question: 'hello', name: 'Bob', tenantId: 'default' };\r\n    const resp = await postJson(\r\n      `${base}/webhook`,\r\n      body,\r\n      { 'x-api-key': String(key) },\r\n      PING_TIMEOUT\r\n    );\r\n    expect(resp.status).toBeGreaterThanOrEqual(200);\r\n    expect(resp.status).toBeLessThan(300);\r\n    expect(resp.data).toBeDefined();\r\n  });\r\n\r\n  test('POST /webhook generate_lesson (best-effort)', async () => {\r\n    const body = { action: 'generate_lesson', question: 'Teach me SPQA', tenantId: 'default' };\r\n    const resp = await postJson(\r\n      `${base}/webhook`,\r\n      body,\r\n      { 'x-api-key': String(key) },\r\n      GENERATE_TIMEOUT\r\n    );\r\n\r\n    // Accept success (2xx) OR a controlled server-side failure (500) when external services are not configured.\r\n    if (resp.status >= 200 && resp.status < 300) {\r\n      if (resp.data && typeof resp.data === 'object') {\r\n        expect(\r\n          resp.data.lessonTitle !== undefined ||\r\n            resp.data.lesson !== undefined ||\r\n            resp.data.reply !== undefined\r\n        ).toBeTruthy();\r\n      } else {\r\n        expect(resp.data).toBeDefined();\r\n      }\r\n    } else {\r\n      // allow 500 but fail other unexpected statuses\r\n      expect(resp.status).toBe(500);\r\n    }\r\n  });\r\n\r\n  test('POST /webhook generate_quiz (best-effort)', async () => {\r\n    const body = { action: 'generate_quiz', question: 'Quiz me on SPQA', tenantId: 'default' };\r\n    const resp = await postJson(\r\n      `${base}/webhook`,\r\n      body,\r\n      { 'x-api-key': String(key) },\r\n      GENERATE_TIMEOUT\r\n    );\r\n\r\n    if (resp.status >= 200 && resp.status < 300) {\r\n      if (resp.data && typeof resp.data === 'object') {\r\n        expect(\r\n          resp.data.quiz !== undefined ||\r\n            resp.data.mcqCount !== undefined ||\r\n            resp.data.mcq !== undefined ||\r\n            resp.data.reply !== undefined\r\n        ).toBeTruthy();\r\n      } else {\r\n        expect(resp.data).toBeDefined();\r\n      }\r\n    } else {\r\n      // allow 500 as above\r\n      expect(resp.status).toBe(500);\r\n    }\r\n  });\r\n});\r\n\r\n// Helper: POST JSON and return { status, data }\r\nfunction postJson(url, body, headers = {}, timeout = 5000) {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      let u;\r\n      try {\r\n        u = new URL(url);\r\n      } catch {\r\n        // Provide a helpful, non-secret diagnostic for CI\r\n        const masked = _maskBaseForLogs(url);\r\n        return reject(\r\n          new Error(`Invalid URL in smoke test (postJson). constructed from base: ${masked}`)\r\n        );\r\n      }\r\n      const data = JSON.stringify(body);\r\n      const options = {\r\n        method: 'POST',\r\n        hostname: u.hostname,\r\n        port: u.port || (u.protocol === 'https:' ? 443 : 80),\r\n        path: u.pathname + u.search,\r\n        // prevent socket pooling / keep-alive so Jest can exit cleanly\r\n        agent: false,\r\n        headers: Object.assign(\r\n          {\r\n            'Content-Type': 'application/json',\r\n            'Content-Length': Buffer.byteLength(data),\r\n            Connection: 'close',\r\n          },\r\n          headers\r\n        ),\r\n      };\r\n\r\n      const transport = u.protocol === 'https:' ? https : http;\r\n      let sockRef = null;\r\n      const req = transport.request(options, (res) => {\r\n        clearTimeout(timer);\r\n        let chunks = [];\r\n        res.on('data', (c) => chunks.push(c));\r\n        res.on('end', () => {\r\n          try {\r\n            const text = Buffer.concat(chunks).toString();\r\n            let json;\r\n            try {\r\n              json = JSON.parse(text);\r\n            } catch {\r\n              json = text;\r\n            }\r\n            resolve({ status: res.statusCode, data: json });\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        });\r\n      });\r\n\r\n      req.on('error', (err) => {\r\n        try {\r\n          clearTimeout(timer);\r\n        } catch {}\r\n        try {\r\n          req.destroy();\r\n        } catch {}\r\n        try {\r\n          if (sockRef && typeof sockRef.destroy === 'function') sockRef.destroy();\r\n        } catch {}\r\n        reject(err);\r\n      });\r\n\r\n      // Instrument the client socket for diagnostics and try to reduce lingering\r\n      req.on('socket', (sock) => {\r\n        sockRef = sock;\r\n        try {\r\n          sock._createdStack = new Error().stack;\r\n        } catch {}\r\n        try {\r\n          if (typeof sock.setNoDelay === 'function') sock.setNoDelay(true);\r\n        } catch {}\r\n        try {\r\n          if (typeof sock.unref === 'function') sock.unref();\r\n        } catch {}\r\n        // ensure we destroy the socket when it closes\r\n        sock.on('close', () => {\r\n          try {\r\n            if (sockRef === sock) sockRef = null;\r\n          } catch {}\r\n        });\r\n      });\r\n\r\n      const timer = setTimeout(() => {\r\n        try {\r\n          req.destroy();\r\n        } catch {}\r\n        try {\r\n          if (sockRef && typeof sockRef.destroy === 'function') sockRef.destroy();\r\n        } catch {}\r\n        reject(new Error('timeout'));\r\n      }, timeout);\r\n\r\n      try {\r\n        req.write(data);\r\n        req.end();\r\n      } catch (e) {\r\n        try {\r\n          clearTimeout(timer);\r\n        } catch {}\r\n        try {\r\n          req.destroy();\r\n        } catch {}\r\n        try {\r\n          if (sockRef && typeof sockRef.destroy === 'function') sockRef.destroy();\r\n        } catch {}\r\n        reject(e);\r\n      }\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  });\r\n}\r\n\r\n// Helper: simple GET returning plain text\r\nfunction getText(url, timeout = 3000) {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      let u;\r\n      try {\r\n        u = new URL(url);\r\n      } catch {\r\n        const masked = _maskBaseForLogs(url);\r\n        return reject(\r\n          new Error(`Invalid URL in smoke test (getText). constructed from base: ${masked}`)\r\n        );\r\n      }\r\n      const options = {\r\n        method: 'GET',\r\n        hostname: u.hostname,\r\n        port: u.port || (u.protocol === 'https:' ? 443 : 80),\r\n        path: u.pathname + u.search,\r\n        agent: false,\r\n        headers: { Connection: 'close' },\r\n      };\r\n\r\n      const transport = u.protocol === 'https:' ? https : http;\r\n      let sockRef = null;\r\n      const req = transport.request(options, (res) => {\r\n        try {\r\n          clearTimeout(timer);\r\n        } catch {}\r\n        let chunks = [];\r\n        res.on('data', (c) => chunks.push(c));\r\n        res.on('end', () => {\r\n          try {\r\n            resolve(Buffer.concat(chunks).toString());\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        });\r\n      });\r\n\r\n      req.on('error', (err) => {\r\n        try {\r\n          clearTimeout(timer);\r\n        } catch {}\r\n        try {\r\n          req.destroy();\r\n        } catch {}\r\n        try {\r\n          if (sockRef && typeof sockRef.destroy === 'function') sockRef.destroy();\r\n        } catch {}\r\n        reject(err);\r\n      });\r\n\r\n      req.on('socket', (sock) => {\r\n        sockRef = sock;\r\n        try {\r\n          if (typeof sock.setNoDelay === 'function') sock.setNoDelay(true);\r\n        } catch {}\r\n        try {\r\n          if (typeof sock.unref === 'function') sock.unref();\r\n        } catch {}\r\n        sock.on('close', () => {\r\n          try {\r\n            if (sockRef === sock) sockRef = null;\r\n          } catch {}\r\n        });\r\n      });\r\n\r\n      const timer = setTimeout(() => {\r\n        try {\r\n          req.destroy();\r\n        } catch {}\r\n        try {\r\n          if (sockRef && typeof sockRef.destroy === 'function') sockRef.destroy();\r\n        } catch {}\r\n        reject(new Error('timeout'));\r\n      }, timeout);\r\n\r\n      try {\r\n        req.end();\r\n      } catch (e) {\r\n        try {\r\n          clearTimeout(timer);\r\n        } catch {}\r\n        try {\r\n          req.destroy();\r\n        } catch {}\r\n        try {\r\n          if (sockRef && typeof sockRef.destroy === 'function') sockRef.destroy();\r\n        } catch {}\r\n        reject(e);\r\n      }\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\peais\\Documents\\Virtual Strategy Tech\\VST NovAIn Voiceflow\\vf-wiring-deterministic\\webhook.legacy\\server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
