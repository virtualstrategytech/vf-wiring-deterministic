name: Deployed smoke (manual)

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'Target environment name (informational)'
        required: false

jobs:
  smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      WEBHOOK_API_KEY: '${{ secrets.WEBHOOK_API_KEY }}'
      WEBHOOK_BASE: '${{ secrets.WEBHOOK_BASE }}'
      DEBUG_WEBHOOK_ENABLED: 'true' # only for debug runs
    outputs:
      webhook_key_fingerprint: ${{ steps.set-fingerprint.outputs.fingerprint }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Validate workflow inputs and secrets
        run: |
          echo "Validating inputs..."
          if [ -z "$WEBHOOK_BASE" ]; then
            echo "ERROR: WEBHOOK_BASE secret is empty." >&2
            exit 1
          fi
          if [ -z "$WEBHOOK_API_KEY" ]; then
            echo "ERROR: WEBHOOK_API_KEY secret is empty." >&2
            exit 1
          fi
          echo "WEBHOOK_BASE is set to: $WEBHOOK_BASE"

      - name: Normalize WEBHOOK_BASE
        run: |
          # Remove any trailing slash(es) from WEBHOOK_BASE so joining paths
          # like "$WEBHOOK_BASE/health" won't produce double-slashes ("//health").
          # Persist normalized value to subsequent steps using $GITHUB_ENV.
          NORMALIZED=${WEBHOOK_BASE%/}
          echo "WEBHOOK_BASE=${NORMALIZED}" >> $GITHUB_ENV
          echo "Normalized WEBHOOK_BASE=${NORMALIZED}"

      - name: Quick readiness check (poll /ready then /health)
        id: health
        run: |
          # Normalize base here to avoid accidental double-slashes when joining paths
          BASE=${WEBHOOK_BASE%/}
          echo "Checking service readiness at $BASE/ready (fallback to /health)"
          attempts=0
          max=18
          http_status=0
          # First try /ready (fast false/200 semantics); if that never becomes 200, fall back to /health
          until [ $attempts -ge $max ]
          do
            attempts=$((attempts+1))
            echo "Attempt $attempts/$max to /ready..."
            http_status=$(curl --silent --show-error --max-time 8 -w '%{http_code}' -o /tmp/ready_body.txt "$BASE/ready" 2>/tmp/ready_err || true)
            echo "ready HTTP status: $http_status"
            if [ "$http_status" = "200" ]; then
              echo "/ready OK"
              cat /tmp/ready_body.txt || true
              break
            fi
            # small delay and try again; allow more time before falling back
            sleep 2
          done
          if [ "$http_status" != "200" ]; then
            echo "/ready did not return 200 within retries, falling back to /health" >&2
            attempts=0
            max=12
            http_status=0
            until [ $attempts -ge $max ]
            do
              attempts=$((attempts+1))
              echo "Attempt $attempts/$max to /health..."
              http_status=$(curl --silent --show-error --fail --max-time 30 -w '%{http_code}' -o /tmp/health_body.txt "$BASE/health" 2>/tmp/health_err || true)
              echo "health HTTP status: $http_status"
              if [ "$http_status" = "200" ]; then
                echo "Health OK"
                cat /tmp/health_body.txt || true
                break
              fi
              echo "Body/Error (health):"
              cat /tmp/health_body.txt || true
              cat /tmp/health_err || true
              sleep 5
            done
          fi
          if [ "$http_status" != "200" ]; then
            echo "Readiness/Health check failed after retries (status $http_status)" >&2
            exit 1
          fi

      - name: Install dependencies (root + webhook)
        run: |
          echo "Installing repository root dependencies (for Jest and CI tools)"
          # Run quick lockfile diagnostic to catch mismatches early
          node scripts/check-locks.js || true
          npm ci
          echo "Installing webhook subpackage dependencies (novain-platform/webhook)"
          cd novain-platform/webhook && npm ci

      - name: Compute fingerprint and export to outputs
        id: set-fingerprint
        run: |
          node -e "const c=require('crypto'); const k=process.env.WEBHOOK_API_KEY||''; const f=k?c.createHash('sha256').update(k).digest('hex').slice(0,16):'missing'; console.log('FINGERPRINT='+f);" > fingerprint.txt
          echo "fingerprint=$(sed -n 's/^FINGERPRINT=//p' fingerprint.txt)" >> $GITHUB_OUTPUT
        shell: bash

      - name: Run deployed smoke tests
        env:
          SKIP_SYNC_SECRET: 'true'
        run: |
          # Initialize persistent socket debug log so artifact is created even if tests time out early
          printf '%s\n' "SOCKET_DEBUG_LOG START: $(date -u)" > /tmp/socket_debug.log || true
          if [ -n "$WEBHOOK_BASE" ]; then echo "WEBHOOK_BASE_HOST=$(echo \"$WEBHOOK_BASE\" | sed -E 's#^https?://([^/]+).*#\1#')" >> /tmp/socket_debug.log || true; fi

          # use a normalized base here as well
          BASE=${WEBHOOK_BASE%/}
          echo "Running smoke tests against $BASE"
          # Run a short, verbose curl trace to capture immediate network issues before Jest
          # Save traces to files so we can upload them on failure for debugging
          echo "Resolving target host for $BASE"
          HOST=$(echo "$BASE" | sed -E 's#^https?://##' | sed -E 's#/.*$##')
          echo "Host: $HOST"
          nslookup "$HOST" > /tmp/dns_trace.txt 2>&1 || true
          ping -c 1 "$HOST" > /tmp/ping_check.txt 2>&1 || true
          echo "Collecting quick curl traces..."
          curl --silent --show-error --max-time 30 -v "$BASE/health" > /tmp/health_trace.txt 2>&1 || true
          printf '%s' '{"action":"ping","question":"ci-check","name":"CI","tenantId":"default"}' > /tmp/ping.json
          curl --silent --show-error --max-time 30 -v -H "Content-Type: application/json" -H "x-api-key: $WEBHOOK_API_KEY" -d @/tmp/ping.json "$BASE/webhook" > /tmp/ping_trace.txt 2>&1 || true

          # Export per-request timeouts for the smoke test runner (millis)
          export WEBHOOK_HEALTH_TIMEOUT=15000
          export WEBHOOK_PING_TIMEOUT=20000
          export WEBHOOK_GENERATE_TIMEOUT=120000
          # Run jest with a slightly larger test timeout to accommodate external slowness
          npx jest tests/webhook.smoke.test.js --runInBand --verbose --testTimeout=180000

      - name: Upload smoke diagnostics (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-diagnostics
          path: |
            /tmp/health_trace.txt
            /tmp/ping_trace.txt
            /tmp/health_body.txt
            /tmp/health_err
            /tmp/socket_debug.log
            scripts/check-locks.js
      - name: Confirm webhook envs (non-secret)
        run: |
          echo "HAS_WEBHOOK_BASE=${WEBHOOK_BASE:+yes}"
          echo "HAS_WEBHOOK_API_KEY=${WEBHOOK_API_KEY:+yes}"
          echo "DEBUG_WEBHOOK_ENABLED=${DEBUG_WEBHOOK_ENABLED:-<missing>}"
